Я работал над логическими функциями, основными из которых являются path_length(Point A, Point B) и flight_path(Point A, Point B). Есть несколько перегрузок даннных функций, но основными являются именно эти две. Рассмотрим их подробнее:

1) функция path_length(Point A, Point B) вычисляет уговой размер расстояния между точками A и B и умножает его на радиус земли. 

2) функция flight_path(Point A, Point B) возвращает оптимальный (наименьший по расстоянию) путь (вектор точек std::vector<Point>) между двумя точками A и B. 

Делает он это следующим образом:

(Основной случай)
a) Если  точки A и B находятся на разных долготах, то путь определяется благодаря функции latitude_function(Point A, Point B, double longitude) Она определяет по точкам A и B и заданной долготе -> заданную широту на пути. 

Важно отметить, что при прохождении +-180 долготы точки на пути резко меняют свою долготу (например 178 -> 179 -> 180 -> -179 -> -178) 

(Специфичный случай)
b) Если  точки A и B находятся на одинаковых долготах, то путь определяется благодаря функции single_flight_path (Point A, Point B) Она возвращает путь на заданной долготе (A.longtitude).
Так как любая долгота это часть большого круга (в отличие от широты), то оптимальным будет путь именно по заданной долготе. (то есть все точки пути имеют одинаковую долготу) 

(Специфичный случай)
c) Если  точки A и B находятся на таких долготах, которые образуют большой круг (например, 50 и -130; -80 и 100), то путь определяется благодаря функции communicating_longitudes(Point A, Point B). Она возвращает путь на заданных долготах (A.longtitude и B.longtitude).
В таком случае путь всегда будет лежать на полюсе Земли (северном или южном) (считаем Землю кругом). 


Проблемы, возникшие при написании фукций:

1) Земля изотропна и между двумя любыми точками определён конкретный путь (кроме точек-антиподов), однако нет единой функции, которая бы определяла путь (вектор точек). Мне пришлось определять разные функции для разных случаев, рассмотрев (как мне кажется все случаи (почти)). Такой подход к решению задачи подвержен ошибкам, которые не так просто выявлять. Получилось много похожего кода, что тоже не очень хорошо.

2) В случае, если точки являются антиподами, то существует бесконечно много путей между такими точками. Однако реализован только один, проходящий через полюс. Это явно не является оптимальным с точки зрения других факторов путем. 

3) Функции библиотеки cmath вычисляют в радианах, и аргументы берут тоже в радианах. Но вот долгота и широта определяется в градусах. Перевести одно в другое несложно. Но вот определить, что ошибка кралась в том, что данные находятся в разных единицах измерения, было куда сложнее. 

4) Было предложение определить 3d путь, который по стоился с учётом эшелонной высоты самолета и препятствий, например, в виде гор. Эту идею мы не стали реализовывать, так как было непонятно, где и как хранятся данные карты, можно ли из них получить вектор точек карты и как его правильно обрабатывать. Эту задачу можно решить, но для простоты нашего проекта зватит и 2d пути. 
